{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"solidago","text":"<p>A toolbox for Solid Algorithmic Governance, used by the Tournesol platform.</p> <p>Version</p> <p>This documentation has been generated from version 0.3.1.</p>"},{"location":"#usage","title":"Usage","text":"Pipeline Usage<pre><code>import logging\nfrom solidago.pipeline import Pipeline\nfrom solidago.pipeline.inputs import TournesolDataset\nfrom solidago.pipeline.outputs import PipelineOutputInMemory\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\n\n# Initialize pipeline with its input and output\ntournesol_dataset = TournesolDataset.download()\npipeline = Pipeline()\noutput = PipelineOutputInMemory()\n\n# Run pipeline\npipeline.run(\n    input=tournesol_dataset,\n    output=PipelineOutputInMemory(),\n    criterion=\"largely_recommended\",\n)\n\n# Access results\nprint(output.individual_scores)\nprint(output.entity_scores)\n</code></pre>"},{"location":"#installation","title":"Installation","text":"<p><code>solidago</code> requires Python &gt;= 3.9</p>"},{"location":"#from-pypi","title":"From PyPI","text":"<p>Using <code>pip</code>:</p> <pre><code>pip install solidago\n</code></pre>"},{"location":"#from-source","title":"From source","text":"<p>TODO</p>"},{"location":"pipeline/","title":"Pipeline","text":""},{"location":"pipeline/#solidago.pipeline.Pipeline","title":"Pipeline","text":"<pre><code>Pipeline(\n    trust_propagation: TrustPropagation = trust_propagation,\n    voting_rights: VotingRightsAssignment = voting_rights,\n    preference_learning: PreferenceLearning = preference_learning,\n    scaling: Scaling = scaling,\n    aggregation: Aggregation = aggregation,\n    post_process: PostProcess = post_process,\n)\n</code></pre> <p>Instantiates the pipeline components.</p> <p>Parameters:</p> Name Type Description Default <code>trust_propagation</code> <code>TrustPropagation</code> <p>Algorithm to spread trust based on pretrusts and vouches</p> <code>trust_propagation</code> <code>voting_rights</code> <code>VotingRightsAssignment</code> <p>Algorithm to assign voting rights to each user</p> <code>voting_rights</code> <code>preference_learning</code> <code>PreferenceLearning</code> <p>Algorithm to learn a user model based on each user's data</p> <code>preference_learning</code> <code>scaling</code> <code>Scaling</code> <p>Algorithm to put user models on a common scale</p> <code>scaling</code> <code>aggregation</code> <code>Aggregation</code> <p>Algorithm to aggregate the different users' models</p> <code>aggregation</code> <code>post_process</code> <code>PostProcess</code> <p>Algorithm to post-process user and global models, and make it readily usable for applications.</p> <code>post_process</code>"},{"location":"pipeline/#solidago.pipeline.Pipeline.run","title":"run","text":"<pre><code>run(\n    input: PipelineInput,\n    criterion: str,\n    output: Optional[PipelineOutput] = None,\n)\n</code></pre> <p>Executes the pipeline with the given input and criterion.</p> <p>Parameters:</p> Name Type Description Default <code>input</code> <code>PipelineInput</code> <p>The input data for the pipeline.</p> required <code>criterion</code> <code>str</code> <p>The criterion used for the pipeline execution.</p> required <code>output</code> <code>Optional[PipelineOutput]</code> <p>The output object to store results, by default None</p> <code>None</code>"},{"location":"pipeline/#solidago.pipeline.Pipeline.__call__","title":"__call__","text":"<pre><code>__call__(\n    users: DataFrame,\n    vouches: DataFrame,\n    entities: DataFrame,\n    privacy: PrivacySettings,\n    judgments: Judgments,\n    init_user_models: Optional[\n        dict[int, ScoringModel]\n    ] = None,\n    output: Optional[PipelineOutput] = None,\n) -&gt; tuple[\n    DataFrame,\n    VotingRights,\n    Mapping[int, ScoringModel],\n    ScoringModel,\n]\n</code></pre> <p>Run Pipeline </p> <p>Parameters:</p> Name Type Description Default <code>users</code> <code>DataFrame</code> <ul> <li>user_id: int (index)</li> <li>is_pretrusted: bool</li> </ul> required <code>vouches</code> <code>DataFrame</code> <ul> <li>voucher (int)</li> <li>vouchee (int)</li> <li>vouch (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id: int (index)</li> </ul> required <code>privacy</code> <code>PrivacySettings</code> <p>privacy[user, entity] in { True, False, None }</p> required <code>judgments</code> <code>Judgments</code> <p>judgments[user] must yield the judgment data provided by the user</p> required <code>init_user_models</code> <code>Optional[dict[int, ScoringModel]]</code> <p>user_models[user] is the user's model</p> <code>None</code> <p>Returns:</p> Name Type Description <code>users</code> <code>DataFrame with columns</code> <ul> <li>user_id: int (index)</li> <li>is_pretrusted: bool</li> <li>trust_score: float</li> </ul> <code>voting_rights</code> <code>VotingRights</code> <p>voting_rights[user, entity] is the user's voting right for entity</p> <code>user_models</code> <code>dict[int, ScoringModel]</code> <p>user_models[user] is the user's model</p> <code>global_model</code> <code>ScoringModel</code> <p>global model</p>"},{"location":"pipeline/#solidago.pipeline.DefaultPipeline","title":"DefaultPipeline","text":"<pre><code>DefaultPipeline\n</code></pre> <p>Instantiates the default pipeline described in \"Solidago: A Modular Pipeline for Collaborative Scaling\".</p>"},{"location":"pipeline/#solidago.pipeline.DefaultPipeline.trust_propagation","title":"trust_propagation","text":"<pre><code>trust_propagation: TrustPropagation = LipschiTrust(\n    pretrust_value=0.8,\n    decay=0.8,\n    sink_vouch=5.0,\n    error=1e-08,\n)\n</code></pre>"},{"location":"pipeline/#solidago.pipeline.DefaultPipeline.voting_rights","title":"voting_rights","text":"<pre><code>voting_rights: VotingRightsAssignment = AffineOvertrust(\n    privacy_penalty=0.5,\n    min_overtrust=2.0,\n    overtrust_ratio=0.1,\n)\n</code></pre>"},{"location":"pipeline/#solidago.pipeline.DefaultPipeline.preference_learning","title":"preference_learning","text":"<pre><code>preference_learning: PreferenceLearning = UniformGBT(\n    prior_std_dev=7,\n    convergence_error=1e-05,\n    cumulant_generating_function_error=1e-05,\n)\n</code></pre>"},{"location":"pipeline/#solidago.pipeline.DefaultPipeline.scaling","title":"scaling","text":"<pre><code>scaling: Scaling = ScalingCompose(\n    Mehestan(\n        lipschitz=0.1,\n        min_activity=10.0,\n        n_scalers_max=100,\n        privacy_penalty=0.5,\n        p_norm_for_multiplicative_resilience=4.0,\n        error=1e-05,\n    ),\n    QuantileZeroShift(\n        zero_quantile=0.15, lipschitz=0.1, error=1e-05\n    ),\n    Standardize(\n        dev_quantile=0.9, lipschitz=0.1, error=1e-05\n    ),\n)\n</code></pre>"},{"location":"pipeline/#solidago.pipeline.DefaultPipeline.aggregation","title":"aggregation","text":"<pre><code>aggregation: Aggregation = EntitywiseQrQuantile(\n    quantile=0.2, lipschitz=0.1, error=1e-05\n)\n</code></pre>"},{"location":"pipeline/#solidago.pipeline.DefaultPipeline.post_process","title":"post_process","text":"<pre><code>post_process: PostProcess = Squash(score_max=100)\n</code></pre>"},{"location":"primitives/","title":"Primitives","text":""},{"location":"primitives/#solidago.primitives.qr_quantile","title":"qr_quantile","text":"<pre><code>qr_quantile(\n    lipschitz: float,\n    quantile: float,\n    values: NDArray,\n    voting_rights: Union[NDArray, float] = 1.0,\n    left_uncertainties: Optional[NDArray] = None,\n    right_uncertainties: Optional[NDArray] = None,\n    default_value: float = 0.0,\n    error: float = 1e-05,\n) -&gt; float\n</code></pre> <p>Computes the quadratically regularized quantile, an estimate of  the quantile of values,weighted by voting_rights, given left and right  uncertainties, and with lipschitz resilience. </p> <p>See Article</p> <p>\"Solidago: A Modular Pipeline for Collaborative Scoring\" on arXiv.</p> <p>Parameters:</p> Name Type Description Default <code>lipschitz</code> <code>float</code> <p>Resilience parameters. Larger values are more resilient, but less accurate.</p> required <code>quantile</code> <code>float</code> <p>Between 0 and 1.</p> required <code>values</code> <code>NDArray</code> <p>Values whose quantile is estimated</p> required <code>voting_rights</code> <code>Union[NDArray, float]</code> <p>Larger voting rights can pull the output towards them with more strength</p> <code>1.0</code> <code>left_uncertainties</code> <code>Optional[NDArray]</code> <p>Left uncertainty on each value. Set to zero if None.</p> <code>None</code> <code>right_uncertainties</code> <code>Optional[NDArray]</code> <p>Right uncertainty. Set to left_uncertainties if None (symmetric uncertainty).</p> <code>None</code> <code>default_value</code> <code>float</code> <p>Default value in the absence of data</p> <code>0.0</code> <code>error</code> <code>float</code> <p>Approximation error</p> <code>1e-05</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float</code> <p>Lipschitz-resilient estimator of the quantile</p>"},{"location":"primitives/#solidago.primitives.qr_median","title":"qr_median","text":"<pre><code>qr_median(\n    lipschitz: float,\n    values: NDArray,\n    voting_rights: Union[NDArray, float] = 1.0,\n    left_uncertainties: Optional[NDArray] = None,\n    right_uncertainties: Optional[NDArray] = None,\n    default_value: float = 0.0,\n    error: float = 1e-05,\n)\n</code></pre> <p>The quadratically regularized median is a Lipschitz-resilient median estimator.  It is equal to the qr_quantile, for quantile = 0.5.</p> <p>See Article</p> <p>\"Robust Sparse Voting\". Youssef Allouah, Rachid Guerraoui, L\u00ea Nguy\u00ean Hoang and Oscar Villemaud (2024). AISTATS.</p> <p>Parameters:</p> Name Type Description Default <code>lipschitz</code> <code>float</code> <p>Resilience parameters. Larger values are more resilient, but less accurate.</p> required <code>values</code> <code>NDArray</code> <p>Values whose quantile is estimated</p> required <code>voting_rights</code> <code>Union[NDArray, float]</code> <p>Larger voting rights can pull the output towards them with more strength</p> <code>1.0</code> <code>left_uncertainties</code> <code>Optional[NDArray]</code> <p>Left uncertainty on each value. Set to zero if None.</p> <code>None</code> <code>right_uncertainties</code> <code>Optional[NDArray]</code> <p>Right uncertainty. Set to left_uncertainties if None (symmetric uncertainty).</p> <code>None</code> <code>default_value</code> <code>float</code> <p>Default value in the absence of data</p> <code>0.0</code> <code>error</code> <code>float</code> <p>Approximation error</p> <code>1e-05</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float</code> <p>Lipschitz-resilient estimator of the median</p>"},{"location":"primitives/#solidago.primitives.qr_standard_deviation","title":"qr_standard_deviation","text":"<pre><code>qr_standard_deviation(\n    lipschitz: float,\n    values: NDArray,\n    quantile_dev: float = 0.5,\n    voting_rights: Union[NDArray, float] = 1.0,\n    left_uncertainties: Optional[NDArray] = None,\n    right_uncertainties: Optional[NDArray] = None,\n    default_dev: float = 1.0,\n    error: float = 1e-05,\n    median: Optional[float] = None,\n)\n</code></pre> <p>Lipschitz-resilient estimator of the standard deviation. Can be understood as a measure of polarization. It roughly measures a median deviation from the median.</p> <p>For heavy-tail distributions of values, we however recommend selecting a higher quantile of deviations from the median.</p> <p>Parameters:</p> Name Type Description Default <code>lipschitz</code> <code>float</code> <p>Resilience parameters. Larger values are more resilient, but less accurate.</p> required <code>values</code> <code>NDArray</code> <p>Values whose quantile is estimated</p> required <code>quantile_dev</code> <code>float</code> <p>Must be between 0 and 1. Defines the quantile of deviations from qr_med that is reported.</p> <code>0.5</code> <code>voting_rights</code> <code>Union[NDArray, float]</code> <p>Larger voting rights can pull the output towards them with more strength</p> <code>1.0</code> <code>left_uncertainties</code> <code>Optional[NDArray]</code> <p>Left uncertainty on each value. Set to zero if None.</p> <code>None</code> <code>right_uncertainties</code> <code>Optional[NDArray]</code> <p>Right uncertainty. Set to left_uncertainties if None (symmetric uncertainty).</p> <code>None</code> <code>default_dev</code> <code>float</code> <p>Default value in the absence of data</p> <code>1.0</code> <code>error</code> <code>float</code> <p>Approximation error</p> <code>1e-05</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float</code> <p>Lipschitz-resilient estimator of the quantile</p>"},{"location":"primitives/#solidago.primitives.qr_uncertainty","title":"qr_uncertainty","text":"<pre><code>qr_uncertainty(\n    lipschitz: float,\n    values: NDArray,\n    voting_rights: Union[NDArray, float] = 1.0,\n    left_uncertainties: Optional[NDArray] = None,\n    right_uncertainties: Optional[NDArray] = None,\n    default_dev: float = 1.0,\n    error: float = 1e-05,\n    median: Optional[float] = None,\n)\n</code></pre> <p>Quadratically regularized uncertainty</p> <p>TODO</p> <p>Search for a better formula for <code>qr_uncertainty</code> if possible.</p>"},{"location":"primitives/#solidago.primitives.clip","title":"clip","text":"<pre><code>clip(values: ndarray, center: float, radius: float)\n</code></pre>"},{"location":"primitives/#solidago.primitives.clip_mean","title":"clip_mean","text":"<pre><code>clip_mean(\n    voting_rights: ndarray,\n    values: ndarray,\n    center: float = 0.0,\n    radius: float = 1.0,\n)\n</code></pre>"},{"location":"primitives/#solidago.primitives.lipschitz_resilient_mean","title":"lipschitz_resilient_mean","text":"<pre><code>lipschitz_resilient_mean(\n    lipschitz: float,\n    values: NDArray,\n    voting_rights: Union[NDArray[float64], float] = 1.0,\n    left_uncertainties: Optional[NDArray] = None,\n    right_uncertainties: Optional[NDArray] = None,\n    default_value: float = 0.0,\n    error: float = 1e-05,\n)\n</code></pre> <p>Lipschitz-robustified mean. Lipschitz-resilient mean estimator. It provably returns the mean, given sufficient participation and bounded values</p> <p>See Article</p> <p>\"Robust Sparse Voting\". Youssef Allouah, Rachid Guerraoui, L\u00ea Nguy\u00ean Hoang and Oscar Villemaud (2024). AISTATS.</p> <p>Parameters:</p> Name Type Description Default <code>lipschitz</code> <code>float</code> <p>Resilience parameters. Larger values are more resilient, but less accurate.</p> required <code>values</code> <code>NDArray</code> <p>Values whose quantile is estimated</p> required <code>voting_rights</code> <code>Union[NDArray[float64], float]</code> <p>Larger voting rights can pull the output towards them with more strength</p> <code>1.0</code> <code>left_uncertainties</code> <code>Optional[NDArray]</code> <p>Left uncertainty on each value. Set to zero if None.</p> <code>None</code> <code>right_uncertainties</code> <code>Optional[NDArray]</code> <p>Right uncertainty. Set to left_uncertainties if None (symmetric uncertainty).</p> <code>None</code> <code>default_value</code> <code>float</code> <p>Default value in the absence of data</p> <code>0.0</code> <code>error</code> <code>float</code> <p>Approximation error</p> <code>1e-05</code> <p>Returns:</p> Name Type Description <code>out</code> <code>float</code> <p>Lipschitz-resilient estimator of the mean</p>"},{"location":"tournesol/","title":"Using Tournesol dataset with Solidago","text":"<p>An instance of <code>TournesolDataset</code> can be used as a pipeline input in Solidago.</p> <pre><code>from solidago.pipeline.inputs import TournesolDataset\n\n# Download the latest dataset from Tournesol API.\npipeline_input = TournesolDataset.download()\n\n# Read a local file\npipeline_input = TournesolDataset(\"path/to/dataset.zip\")\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset","title":"TournesolDataset","text":"<pre><code>TournesolDataset(dataset_zip: Union[str, BinaryIO])\n</code></pre> <p>               Bases: <code>PipelineInput</code></p> <p>Initilialize a Pipeline input, by loading a tournesol dataset (.zip format) from a local file, or a URL.</p>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.users","title":"users","text":"<pre><code>users = read_csv(users_file, keep_default_na=False)\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.vouchers","title":"vouchers","text":"<pre><code>vouchers = read_csv(vouchers_file, keep_default_na=False)\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.username_to_user_id","title":"username_to_user_id","text":"<pre><code>username_to_user_id = Series(\n    data=index, index=users[\"public_username\"]\n)\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.entity_id_to_video_id","title":"entity_id_to_video_id","text":"<pre><code>entity_id_to_video_id = Series(\n    sorted(set(video_a) | set(video_b) | set(video)),\n    name=\"video_id\",\n)\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.video_id_to_entity_id","title":"video_id_to_entity_id","text":"<pre><code>video_id_to_entity_id = {\n    video_id: _zCpVCz29for(entity_id, video_id) in items()\n}\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.collective_scores","title":"collective_scores","text":"<pre><code>collective_scores = drop(columns=['video'])\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.comparisons","title":"comparisons","text":"<pre><code>comparisons = drop(columns=['video_a', 'video_b'])\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.individual_scores","title":"individual_scores","text":"<pre><code>individual_scores = drop(\n    columns=[\"public_username\", \"video\"]\n)\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.ratings_properties","title":"ratings_properties","text":"<pre><code>ratings_properties\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.download","title":"download","text":"<pre><code>download() -&gt; TournesolDataset\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.get_comparisons","title":"get_comparisons","text":"<pre><code>get_comparisons(criterion=None, user_id=None) -&gt; DataFrame\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.get_individual_scores","title":"get_individual_scores","text":"<pre><code>get_individual_scores(\n    user_id: Optional[int] = None,\n    criterion: Optional[str] = None,\n    with_n_comparisons=False,\n) -&gt; DataFrame\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.get_collective_scores","title":"get_collective_scores","text":"<pre><code>get_collective_scores(\n    entity_id: Optional[str] = None,\n    criterion: Optional[str] = None,\n) -&gt; DataFrame\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.get_vouches","title":"get_vouches","text":"<pre><code>get_vouches()\n</code></pre>"},{"location":"tournesol/#solidago.pipeline.inputs.TournesolDataset.get_users","title":"get_users","text":"<pre><code>get_users()\n</code></pre>"},{"location":"modules/aggregation/","title":"Aggregation","text":"<p>Step 5 of the pipeline.</p> <p>Aggregation combines the different user models to construct a global model. The aggregation may also adjust the user models to the learned global model.</p>"},{"location":"modules/aggregation/#solidago.aggregation.Aggregation","title":"Aggregation","text":""},{"location":"modules/aggregation/#solidago.aggregation.Aggregation.__call__","title":"__call__","text":"<pre><code>__call__(\n    voting_rights: VotingRights,\n    user_models: Mapping[int, ScoringModel],\n    users: DataFrame,\n    entities: DataFrame,\n) -&gt; tuple[dict[int, ScoringModel], ScoringModel]\n</code></pre> <p>Returns scaled user models</p> <p>Parameters:</p> Name Type Description Default <code>voting_rights</code> <code>VotingRights</code> <p>voting_rights[user, entity]: float</p> required <code>user_models</code> <code>Mapping[int, ScoringModel]</code> <p>user_models[user] is user's scoring model</p> required <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, ind)</li> </ul> required <p>Returns:</p> Name Type Description <code>updated_user_models[user]: ScoringModel</code> <p>Returns a scaled user model</p> <code>global_model</code> <code>ScoringModel</code> <p>Returns a global scoring model</p>"},{"location":"modules/aggregation/#solidago.aggregation.Average","title":"Average","text":"<p>               Bases: <code>Aggregation</code></p>"},{"location":"modules/aggregation/#solidago.aggregation.Average.__call__","title":"__call__","text":"<pre><code>__call__(\n    voting_rights: VotingRights,\n    user_models: dict[int, ScoringModel],\n    users: DataFrame,\n    entities: DataFrame,\n) -&gt; tuple[dict[int, ScoringModel], ScoringModel]\n</code></pre> <p>Returns scaled user models</p> <p>Parameters:</p> Name Type Description Default <code>voting_rights</code> <code>VotingRights</code> <p>voting_rights[user, entity]: float</p> required <code>user_models</code> <code>dict[int, ScoringModel]</code> <p>user_models[user] is user's scoring model</p> required <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, ind)</li> </ul> required <p>Returns:</p> Name Type Description <code>updated_user_models[user]: ScoringModel</code> <p>Returns a scaled user model</p> <code>global_model</code> <code>ScoringModel</code> <p>Returns a global scoring model</p>"},{"location":"modules/aggregation/#solidago.aggregation.EntitywiseQrQuantile","title":"EntitywiseQrQuantile","text":"<pre><code>EntitywiseQrQuantile(\n    quantile=0.2, lipschitz=0.1, error=1e-05\n)\n</code></pre> <p>               Bases: <code>Aggregation</code></p> <p>Aggregates the scores per entity with <code>qr_quantile</code>.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <code>0.2</code> <code>lipschitz</code> <code>0.1</code> <code>error</code> <code>1e-05</code>"},{"location":"modules/aggregation/#solidago.aggregation.EntitywiseQrQuantile.__call__","title":"__call__","text":"<pre><code>__call__(\n    voting_rights: VotingRights,\n    user_models: dict[int, ScoringModel],\n    users: DataFrame,\n    entities: DataFrame,\n) -&gt; tuple[dict[int, ScoringModel], ScoringModel]\n</code></pre> <p>Returns scaled user models</p> <p>Parameters:</p> Name Type Description Default <code>voting_rights</code> <code>VotingRights</code> <p>voting_rights[user, entity]: float</p> required <code>user_models</code> <code>dict[int, ScoringModel]</code> <p>user_models[user] is user's scoring model</p> required <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, ind)</li> </ul> required <p>Returns:</p> Name Type Description <code>updated_user_models[user]: ScoringModel</code> <p>Returns a scaled user model</p> <code>global_model</code> <code>ScoringModel</code> <p>Returns a global scoring model</p>"},{"location":"modules/aggregation/#solidago.aggregation.StandardizedQrQuantile","title":"StandardizedQrQuantile","text":"<pre><code>StandardizedQrQuantile(\n    quantile=0.2,\n    dev_quantile=0.9,\n    lipschitz=0.1,\n    error=1e-05,\n)\n</code></pre> <p>               Bases: <code>Aggregation</code></p> <p>Standardize scores so that only a fraction <code>1 - dev_quantile</code> of the scores is further than 1 away from the requested <code>quantile</code>, and then run <code>qr_quantile</code> to aggregate the scores.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <code>0.2</code> <code>dev_quantile</code> <code>0.9</code> <code>lipschitz</code> <code>0.1</code> <code>error</code> <code>1e-05</code>"},{"location":"modules/aggregation/#solidago.aggregation.StandardizedQrQuantile.__call__","title":"__call__","text":"<pre><code>__call__(\n    voting_rights: VotingRights,\n    user_models: dict[int, ScoringModel],\n    users: DataFrame,\n    entities: DataFrame,\n) -&gt; tuple[dict[int, ScaledScoringModel], ScoringModel]\n</code></pre> <p>Returns scaled user models</p> <p>Parameters:</p> Name Type Description Default <code>voting_rights</code> <code>VotingRights</code> <p>voting_rights[user, entity]: float</p> required <code>user_models</code> <code>dict[int, ScoringModel]</code> <p>user_models[user] is user's scoring model</p> required <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, ind)</li> </ul> required <p>Returns:</p> Name Type Description <code>updated_user_models[user]: ScoringModel</code> <p>Returns a scaled user model</p> <code>global_model</code> <code>ScoringModel</code> <p>Returns a global scoring model</p>"},{"location":"modules/post_process/","title":"Post process","text":"<p>Step 6 of the pipeline.</p> <p>Post-process modifies the user and global models, typically with the goal of yielding more human-readible scores.</p>"},{"location":"modules/post_process/#solidago.post_process.PostProcess","title":"PostProcess","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"modules/post_process/#solidago.post_process.PostProcess.__call__","title":"__call__","text":"<pre><code>__call__(\n    user_models: Mapping[int, ScoringModel],\n    global_model: ScoringModel,\n    entities: DataFrame,\n) -&gt; tuple[Mapping[int, ScoringModel], ScoringModel]\n</code></pre> <p>Post-processes user models and global models, typically to yield human-readible scores</p> <p>Parameters:</p> Name Type Description Default <code>user_models</code> <code>Mapping[int, ScoringModel]</code> required <code>global_model</code> <code>ScoringModel</code> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, index)</li> </ul> required <p>Returns:</p> Name Type Description <code>user_models</code> <code>post-processed user models</code> <code>global_model</code> <code>post-processed global model</code>"},{"location":"modules/post_process/#solidago.post_process.NoPostProcess","title":"NoPostProcess","text":"<p>               Bases: <code>PostProcess</code></p>"},{"location":"modules/post_process/#solidago.post_process.NoPostProcess.__call__","title":"__call__","text":"<pre><code>__call__(\n    user_models: dict[int, ScoringModel],\n    global_model: ScoringModel,\n    entities: DataFrame,\n) -&gt; tuple[dict[int, ScoringModel], ScoringModel]\n</code></pre> <p>Post-processes user models and global models, typically to yield human-readible scores</p> <p>Parameters:</p> Name Type Description Default <code>user_models</code> <code>dict[int, ScoringModel]</code> required <code>global_model</code> <code>ScoringModel</code> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, index)</li> </ul> required <p>Returns:</p> Name Type Description <code>user_models</code> <code>post-processed user models</code> <code>global_model</code> <code>post-processed global model</code>"},{"location":"modules/post_process/#solidago.post_process.Squash","title":"Squash","text":"<pre><code>Squash(score_max: float = 100.0)\n</code></pre> <p>               Bases: <code>PostProcess</code></p>"},{"location":"modules/post_process/#solidago.post_process.Squash.__call__","title":"__call__","text":"<pre><code>__call__(\n    user_models: Mapping[int, ScoringModel],\n    global_model: ScoringModel,\n    entities: Optional[DataFrame] = None,\n) -&gt; tuple[Mapping[int, ScoringModel], ScoringModel]\n</code></pre> <p>Post-processes user models and global models, typically to yield human-readable scores</p> <p>Parameters:</p> Name Type Description Default <code>user_models</code> <code>Mapping[int, ScoringModel]</code> required <code>global_model</code> <code>ScoringModel</code> required <code>entities</code> <code>Optional[DataFrame]</code> <ul> <li>entity_id (int, index)</li> </ul> <code>None</code> <p>Returns:</p> Name Type Description <code>user_models</code> <code>post-processed user models</code> <code>global_model</code> <code>post-processed global model</code>"},{"location":"modules/preference_learning/","title":"Preference learning","text":"<p>Step 3 of the pipeline</p> <p>Preference learning infers, for each user and based on their data, a model of the user's preferences. This corresponds to the idea of \"algorithmic representatives\",  which will participate in the digital democracy  to remedy users' lack of activity and reactivity.</p>"},{"location":"modules/preference_learning/#solidago.preference_learning.PreferenceLearning","title":"PreferenceLearning","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"modules/preference_learning/#solidago.preference_learning.PreferenceLearning.__call__","title":"__call__","text":"<pre><code>__call__(\n    judgments: Judgments,\n    users: DataFrame,\n    entities: DataFrame,\n    initialization: Optional[\n        dict[int, ScoringModel]\n    ] = None,\n    new_judgments: Optional[Judgments] = None,\n) -&gt; dict[int, ScoringModel]\n</code></pre> <p>Learns a scoring model, given user judgments of entities</p> <p>Parameters:</p> Name Type Description Default <code>judgments</code> <code>Judgments</code> <p>May contain different forms of judgments, but most likely will contain \"comparisons\" and/or \"assessments\"</p> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id: int, index</li> <li>May contain others, such as vector representation</li> </ul> required <code>initialization</code> <code>Optional[dict[int, ScoringModel]]</code> <p>Starting models, added to facilitate optimization It is not supposed to affect the output of the training</p> <code>None</code> <code>new_judgments</code> <code>Optional[Judgments]</code> <p>New judgments This allows to prioritize coordinate descent, starting with newly evaluated entities</p> <code>None</code> <p>Returns:</p> Name Type Description <code>user_models</code> <code>dict[int, ScoringModel]</code> <p>user_models[user] is the learned scoring model for user</p>"},{"location":"modules/preference_learning/#solidago.preference_learning.PreferenceLearning.user_learn","title":"user_learn","text":"<pre><code>user_learn(\n    user_judgments: dict[str, DataFrame],\n    entities: DataFrame,\n    initialization: Optional[ScoringModel] = None,\n    new_judgments: Optional[dict[str, DataFrame]] = None,\n) -&gt; ScoringModel\n</code></pre> <p>Learns a scoring model, given user judgments of entities</p> <p>Parameters:</p> Name Type Description Default <code>user_judgments</code> <code>dict[str, DataFrame]</code> <p>May contain different forms of judgments, but most likely will contain \"comparisons\" and/or \"assessments\"</p> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id: int, index</li> <li>May contain others, such as vector representation</li> </ul> required <code>initialization</code> <code>Optional[ScoringModel]</code> <p>Starting model, added to facilitate optimization It is not supposed to affect the output of the training</p> <code>None</code> <code>new_judgments</code> <code>Optional[dict[str, DataFrame]]</code> <p>New judgments This allows to prioritize coordinate descent, starting with newly evaluated entities</p> <code>None</code> <p>Returns:</p> Name Type Description <code>model</code> <code>ScoringModel</code>"},{"location":"modules/preference_learning/#solidago.preference_learning.UniformGBT","title":"UniformGBT","text":"<pre><code>UniformGBT(\n    prior_std_dev: float = 7.0,\n    convergence_error: float = 1e-05,\n    cumulant_generating_function_error: float = 1e-05,\n    high_likelihood_range_threshold: float = 1.0,\n)\n</code></pre> <p>               Bases: <code>GeneralizedBradleyTerry</code></p> Parameters (TODO)"},{"location":"modules/preference_learning/#solidago.preference_learning.LBFGSUniformGBT","title":"LBFGSUniformGBT","text":"<pre><code>LBFGSUniformGBT(\n    prior_std_dev: float = 7,\n    convergence_error: float = 1e-05,\n    cumulant_generating_function_error: float = 1e-05,\n    max_iter: int = 100,\n    high_likelihood_range_threshold: float = 1.0,\n)\n</code></pre> <p>               Bases: <code>LBFGSGeneralizedBradleyTerry</code></p> Parameters (TODO)"},{"location":"modules/preference_learning/#solidago.preference_learning.LBFGSUniformGBT.cumulant_generating_function","title":"cumulant_generating_function","text":"<pre><code>cumulant_generating_function(score_diff: Tensor) -&gt; Tensor\n</code></pre> <p>For.</p> <p>Parameters:</p> Name Type Description Default <code>score_diff</code> <code>Tensor</code> <p>Score difference</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>float</code>"},{"location":"modules/scaling/","title":"Scaling","text":"<p>Step 4 of the pipeline.</p> <p>Scaling addresses the \"Parisian\" and the \"Marseillais\" problems, i.e. users with too extreme scores,  or whose negative scores correspond to entities that others rate as positive. This latter effect is particularly an issue in comparison-based preference learning, assuming each user has a very specific selection bias of rated entities.</p>"},{"location":"modules/scaling/#solidago.scaling.Scaling","title":"Scaling","text":""},{"location":"modules/scaling/#solidago.scaling.Scaling.__call__","title":"__call__","text":"<pre><code>__call__(\n    user_models: Mapping[int, ScoringModel],\n    users: DataFrame,\n    entities: DataFrame,\n    voting_rights: VotingRights,\n    privacy: PrivacySettings,\n) -&gt; dict[int, ScaledScoringModel]\n</code></pre> <p>Returns scaled user models</p> <p>Parameters:</p> Name Type Description Default <code>user_models</code> <code>Mapping[int, ScoringModel]</code> <p>user_models[user] is user's scoring model</p> required <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, ind)</li> </ul> required <code>voting_rights</code> <code>VotingRights</code> <p>voting_rights[user, entity]: float</p> required <code>privacy</code> <code>PrivacySettings</code> <p>privacy[user, entity] in { True, False, None }</p> required <p>Returns:</p> Type Description <code>out[user]: ScoringModel</code> <p>Will be scaled by the Scaling method</p>"},{"location":"modules/scaling/#solidago.scaling.Scaling.to_json","title":"to_json","text":"<pre><code>to_json() -&gt; tuple\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.ScalingCompose","title":"ScalingCompose","text":"<pre><code>ScalingCompose(*scalings: Scaling)\n</code></pre> <p>               Bases: <code>Scaling</code></p> <p>Class used to compose any number of scaling solutions</p> <p>Composes a list of scalings</p>"},{"location":"modules/scaling/#solidago.scaling.ScalingCompose.scalings","title":"scalings","text":"<pre><code>scalings = scalings\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.ScalingCompose.__call__","title":"__call__","text":"<pre><code>__call__(\n    user_models, users, entities, voting_rights, privacy\n) -&gt; dict[int, ScaledScoringModel]\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.ScalingCompose.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.NoScaling","title":"NoScaling","text":"<p>               Bases: <code>Scaling</code></p>"},{"location":"modules/scaling/#solidago.scaling.NoScaling.__call__","title":"__call__","text":"<pre><code>__call__(\n    user_models: Mapping[int, ScoringModel],\n    users: DataFrame = ...,\n    entities: DataFrame = ...,\n    voting_rights: VotingRights = ...,\n    privacy: PrivacySettings = ...,\n) -&gt; dict[int, ScaledScoringModel]\n</code></pre> <p>Returns scaled user models</p> <p>Parameters:</p> Name Type Description Default <code>user_models</code> <code>Mapping[int, ScoringModel]</code> <p>user_models[user] is user's scoring model</p> required <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> <code>...</code> <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, ind)</li> </ul> <code>...</code> <code>voting_rights</code> <code>VotingRights</code> <p>voting_rights[user, entity]: float</p> <code>...</code> <code>privacy</code> <code>PrivacySettings</code> <p>privacy[user, entity] in { True, False, None }</p> <code>...</code> <p>Returns:</p> Type Description <code>out[user]: ScoringModel</code> <p>Will be scaled by the Scaling method</p>"},{"location":"modules/scaling/#solidago.scaling.Mehestan","title":"Mehestan","text":"<pre><code>Mehestan(\n    lipschitz: float = 0.1,\n    min_activity: float = 10.0,\n    n_scalers_max: int = 100,\n    privacy_penalty: float = 0.5,\n    user_comparison_lipschitz: float = 10.0,\n    p_norm_for_multiplicative_resilience: float = 4.0,\n    n_diffs_sample_max: int = 1000,\n    error: float = 1e-05,\n)\n</code></pre> <p>               Bases: <code>Scaling</code></p> <p>Mehestan performs Lipschitz-resilient ollaborative scaling.</p> <p>A simplified version of Mehestan was published in  \"Robust Sparse Voting\", Youssef Allouah, Rachid Guerraoui, L\u0229 Nguy\u00ean Hoang and Oscar Villemaud, published at AISTATS 2024.</p> <p>The inclusion of uncertainties is further detailed in \"Solidago: A Modular Pipeline for Collaborative Scoring\"</p> <p>Parameters:</p> Name Type Description Default <code>lipschitz</code> <code>float</code> <p>Resilience parameters. Larger values are more resilient, but less accurate.</p> <code>0.1</code> <code>min_activity</code> <code>float</code> <p>Minimal activity (e.g based on number of comparisons) to be a potential scaler.</p> <code>10.0</code> <code>n_scalers_max</code> <code>int</code> <p>Maximal number of scalers</p> <code>100</code> <code>privacy_penalty</code> <code>float</code> <p>Penalty to private ratings when selecting scalers</p> <code>0.5</code> <code>p_norm_for_multiplicative_resilience</code> <code>float</code> <p>To provide stronger security,  we enforce a large resilience on multiplicator estimation, when the model scores of a user are large. The infinite norm may be to sensitive to extreme values, thus we propose to use an l_p norm.</p> <code>4.0</code> <code>error</code> <code>float</code> <p>Error bound</p> <code>1e-05</code>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.lipschitz","title":"lipschitz","text":"<pre><code>lipschitz = lipschitz\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.min_activity","title":"min_activity","text":"<pre><code>min_activity = min_activity\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.n_scalers_max","title":"n_scalers_max","text":"<pre><code>n_scalers_max = n_scalers_max\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.privacy_penalty","title":"privacy_penalty","text":"<pre><code>privacy_penalty = privacy_penalty\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.user_comparison_lipschitz","title":"user_comparison_lipschitz","text":"<pre><code>user_comparison_lipschitz = user_comparison_lipschitz\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.p_norm_for_multiplicative_resilience","title":"p_norm_for_multiplicative_resilience","text":"<pre><code>p_norm_for_multiplicative_resilience = (\n    p_norm_for_multiplicative_resilience\n)\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.n_diffs_sample_max","title":"n_diffs_sample_max","text":"<pre><code>n_diffs_sample_max = n_diffs_sample_max\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.error","title":"error","text":"<pre><code>error = error\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.__call__","title":"__call__","text":"<pre><code>__call__(\n    user_models: Mapping[int, ScoringModel],\n    users: DataFrame,\n    entities: DataFrame,\n    voting_rights: Optional[VotingRights] = None,\n    privacy: Optional[PrivacySettings] = None,\n) -&gt; dict[int, ScaledScoringModel]\n</code></pre> <p>Returns scaled user models</p> <p>Parameters:</p> Name Type Description Default <code>user_models</code> <code>Mapping[int, ScoringModel]</code> <p>user_models[user] is user's scoring model</p> required <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, ind)</li> </ul> required <code>voting_rights</code> <code>Optional[VotingRights]</code> <p>Not used in Mehestan</p> <code>None</code> <code>privacy</code> <code>Optional[PrivacySettings]</code> <p>privacy[user, entity] in { True, False, None }</p> <code>None</code> <p>Returns:</p> Type Description <code>out[user]: ScoringModel</code> <p>Will be scaled by the Scaling method</p>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.compute_scalers","title":"compute_scalers","text":"<pre><code>compute_scalers(\n    user_models: Mapping[int, ScoringModel],\n    entities: DataFrame,\n    users: DataFrame,\n    privacy: Optional[PrivacySettings],\n) -&gt; ndarray\n</code></pre> <p>Determines which users will be scalers. The set of scalers is restricted for two reasons. First, too inactive users are removed, because their lack of comparability with other users makes the scaling process ineffective. Second, scaling scalers is the most computationally demanding step of Mehestan. Reducing the number of scalers accelerates the computation.</p> Parameters (TODO) <p>Returns:</p> Name Type Description <code>is_scaler</code> <code>ndarray</code> <p>is_scaler[user]: bool says whether user is a scaler</p>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.scale_scalers","title":"scale_scalers","text":"<pre><code>scale_scalers(user_models, scalers, entities, privacy)\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.scale_non_scalers","title":"scale_non_scalers","text":"<pre><code>scale_non_scalers(\n    user_models,\n    nonscalers,\n    entities,\n    scalers,\n    scaled_models,\n    privacy,\n)\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.compute_activities","title":"compute_activities","text":"<pre><code>compute_activities(\n    user_models: Mapping[int, ScoringModel],\n    entities: DataFrame,\n    users: DataFrame,\n    privacy: Optional[PrivacySettings],\n) -&gt; dict[int, float]\n</code></pre> <p>Returns a dictionary, which maps users to their trustworthy activeness.</p> <p>Parameters:</p> Name Type Description Default <code>user_models</code> <code>Mapping[int, ScoringModel]</code> required <code>entities</code> <code>DataFrame</code> required <code>users</code> <code>DataFrame</code> required <code>privacy</code> <code>Optional[PrivacySettings]</code> <p>privacy[user, entity] in { True, False, None }</p> required <p>Returns:</p> Name Type Description <code>activities</code> <code>dict[int, float]</code> <p>activities[user] is a measure of user's trustworthy activeness.</p>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.compute_model_norms","title":"compute_model_norms","text":"<pre><code>compute_model_norms(\n    user_models: dict[int, ScoringModel],\n    users: DataFrame,\n    entities: DataFrame,\n    privacy: PrivacySettings,\n) -&gt; dict[int, float]\n</code></pre> <p>Estimator of the scale of scores of a user, with an emphasis on large scores. The estimator uses a L_power norm, and weighs scores, depending on public/private status. For each user u, it computes (sum_e w[ue] * score[u, e]power / sum_e w[ue])(1/power).</p> <p>Parameters:</p> Name Type Description Default <code>user_models</code> <code>dict[int, ScoringModel]</code> <p>user_models[user] is user's scoring model</p> required <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, ind)</li> </ul> required <code>privacy</code> <code>PrivacySettings</code> <p>privacy[user, entity] in { True, False, None }</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>dict[int, float]</code> <p>out[user]</p>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.compute_entity_ratios","title":"compute_entity_ratios","text":"<pre><code>compute_entity_ratios(\n    scalee_models: dict[int, ScoringModel],\n    scaler_models: dict[int, ScoringModel],\n    entities: DataFrame,\n    privacy: PrivacySettings,\n) -&gt; dict[\n    int,\n    dict[\n        int,\n        tuple[\n            list[float],\n            list[float],\n            list[float],\n            list[float],\n        ],\n    ],\n]\n</code></pre> <p>Computes the ratios of score differences, with uncertainties, for comparable entities of any pair of scalers (\\(s_{uvef}\\) in paper), for \\(u\\) in scalees and \\(v\\) in scalers. Note that the output <code>ratios[u][v]</code> is given as a 1-dimensional np.ndarray without any reference to e and f.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, index)</li> </ul> required <code>scalee_models</code> <code>dict[int, ScoringModel]</code> <p>scalee_models[user_id] is a scoring model</p> required <code>scaler_models</code> <code>dict[int, ScoringModel]</code> <p>scaler_models[user_id] is a scoring model</p> required <code>privacy</code> <code>PrivacySettings</code> required <p>Returns:</p> Name Type Description <code>out</code> <code>dict[int, dict[int, tuple[list[float], list[float], list[float], list[float]]]]</code> <p><code>out[user][user_bis]</code> is a tuple (ratios, voting_rights, lefts, rights), where ratios is a list of ratios of score differences, and left and right are the left and right ratio uncertainties.</p>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.load_all_ratios","title":"load_all_ratios","text":"<pre><code>load_all_ratios(\n    u: int,\n    v: int,\n    uv_entities: list[int],\n    entities: DataFrame,\n    u_model: ScoringModel,\n    v_model: ScoringModel,\n    privacy: Optional[PrivacySettings],\n) -&gt; Optional[\n    tuple[\n        list[float], list[float], list[float], list[float]\n    ]\n]\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.sample_ratios","title":"sample_ratios","text":"<pre><code>sample_ratios(\n    u: int,\n    v: int,\n    uv_entities: list[int],\n    entities: DataFrame,\n    u_model: ScoringModel,\n    v_model: ScoringModel,\n    privacy: Optional[PrivacySettings],\n) -&gt; tuple[\n    list[float], list[float], list[float], list[float]\n]\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.compute_multiplicators","title":"compute_multiplicators","text":"<pre><code>compute_multiplicators(\n    voting_rights: dict[int, list[float]],\n    ratios: dict[int, list[float]],\n    uncertainties: dict[int, list[float]],\n    model_norms: dict[int, float],\n) -&gt; dict[int, tuple[float, float]]\n</code></pre> <p>Computes the multiplicators of users with given user_ratios</p> <p>Parameters:</p> Name Type Description Default <code>ratios</code> <code>dict[int, list[float]]</code> <p><code>ratios[u][0]</code> is a list of voting rights <code>ratios[u][1]</code> is a list of ratios <code>ratios[u][2]</code> is a list of (symmetric) uncertainties</p> required <code>model_norms</code> <code>dict[int, float]</code> <p>model_norms[u] estimates the norm of user u's score model</p> required <p>Returns:</p> Name Type Description <code>multiplicators</code> <code>dict[int, tuple[float, float]]</code> <p><code>multiplicators[user][0]</code> is the multiplicative scaling of user <code>multiplicators[user][1]</code> is the uncertainty on the multiplicator</p>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.compute_entity_diffs","title":"compute_entity_diffs","text":"<pre><code>compute_entity_diffs(\n    scalee_models: dict[int, ScoringModel],\n    scaler_models: dict[int, ScoringModel],\n    entities: DataFrame,\n    privacy: PrivacySettings,\n    multiplicators: dict[int, tuple[float, float]],\n) -&gt; dict[\n    int,\n    dict[\n        int,\n        tuple[\n            list[float],\n            list[float],\n            list[float],\n            list[float],\n        ],\n    ],\n]\n</code></pre> <p>Computes the differences of scores, with uncertainties, for shared entities of any pair of scalers (\\(s_{uvef}\\) in paper). Note that the output is given as a 1-dimensional np.ndarray without any reference to e and f.</p> <p>Parameters:</p> Name Type Description Default <code>scalee_models</code> <code>dict[int, ScoringModel]</code> required <code>scaler_models</code> <code>dict[int, ScoringModel]</code> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, index)</li> </ul> required <code>multiplicators</code> <code>dict[int, tuple[float, float]]</code> <p><code>multiplicators[user][0]</code> is the multiplicative scaling of user <code>multiplicators[user][1]</code> is the uncertainty on the multiplicator</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>dict[int, dict[int, tuple[list[float], list[float], list[float]]]]</code> <p><code>out[user][user_bis]</code> is a tuple (differences, voting_rights, lefts, rights).</p>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.compute_translations","title":"compute_translations","text":"<pre><code>compute_translations(\n    voting_rights: dict[int, list[float]],\n    diffs: dict[int, list[float]],\n    uncertainties: dict[int, list[float]],\n) -&gt; dict[int, tuple[float, float]]\n</code></pre> <p>Computes the translation of users with given <code>diffs</code>.</p> <p>Returns:</p> Name Type Description <code>translations</code> <code>dict[int, tuple[float, float]]</code> <p><code>translations[user][0]</code> is the multiplicative scaling of user <code>translations[user][1]</code> is the uncertainty on the translation</p>"},{"location":"modules/scaling/#solidago.scaling.Mehestan.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.QuantileShift","title":"QuantileShift","text":"<pre><code>QuantileShift(\n    quantile: float = 0.15,\n    *,\n    target_score: float = 0.0,\n    lipschitz: float = 0.1,\n    error: float = 1e-05\n)\n</code></pre> <p>               Bases: <code>Scaling</code></p> <p>Shifts the scores so that their <code>quantile</code> (computed with <code>qr_quantile</code>) value equals <code>target_score</code>.</p> <p>Parameters:</p> Name Type Description Default <code>quantile</code> <code>float</code> <code>0.15</code> <code>target_score</code> <code>float</code> <code>0.0</code> <code>lipschitz</code> <code>float</code> <code>0.1</code> <code>error</code> <code>float</code> <code>1e-05</code>"},{"location":"modules/scaling/#solidago.scaling.QuantileShift.quantile","title":"quantile","text":"<pre><code>quantile = quantile\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.QuantileShift.target_score","title":"target_score","text":"<pre><code>target_score = target_score\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.QuantileShift.lipschitz","title":"lipschitz","text":"<pre><code>lipschitz = lipschitz\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.QuantileShift.error","title":"error","text":"<pre><code>error = error\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.QuantileShift.__call__","title":"__call__","text":"<pre><code>__call__(\n    user_models: Mapping[int, ScoringModel],\n    users: DataFrame,\n    entities: DataFrame,\n    voting_rights: VotingRights,\n    privacy: PrivacySettings,\n) -&gt; dict[int, ScaledScoringModel]\n</code></pre> <p>Returns scaled user models</p> <p>Parameters:</p> Name Type Description Default <code>user_models</code> <code>Mapping[int, ScoringModel]</code> <p>user_models[user] is user's scoring model</p> required <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, ind)</li> </ul> required <code>voting_rights</code> <code>VotingRights</code> <p>voting_rights[user, entity]: float</p> required <code>privacy</code> <code>PrivacySettings</code> <p>privacy[user, entity] in { True, False, None }</p> required <p>Returns:</p> Type Description <code>out[user]: ScoringModel</code> <p>Will be scaled by the Scaling method</p>"},{"location":"modules/scaling/#solidago.scaling.QuantileShift.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Standardize","title":"Standardize","text":"<pre><code>Standardize(\n    dev_quantile: float = 0.9,\n    lipschitz: float = 0.1,\n    error: float = 1e-05,\n)\n</code></pre> <p>               Bases: <code>Scaling</code></p>"},{"location":"modules/scaling/#solidago.scaling.Standardize.dev_quantile","title":"dev_quantile","text":"<pre><code>dev_quantile = dev_quantile\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Standardize.lipschitz","title":"lipschitz","text":"<pre><code>lipschitz = lipschitz\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Standardize.error","title":"error","text":"<pre><code>error = error\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Standardize.__call__","title":"__call__","text":"<pre><code>__call__(\n    user_models: dict[int, ScoringModel],\n    users: DataFrame,\n    entities: DataFrame,\n    voting_rights: VotingRights,\n    privacy: PrivacySettings,\n)\n</code></pre>"},{"location":"modules/scaling/#solidago.scaling.Standardize.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/trust_propagation/","title":"Trust propagation","text":"<p>Step 1 in the pipeline</p> <p>Trust propagation is tasked to combine pretrusts and vouches to derive trust scores for the different users.</p>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.TrustPropagation","title":"TrustPropagation","text":"<p>               Bases: <code>ABC</code></p> <p>Base class for Trust Propagation algorithms</p>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.TrustPropagation.__call__","title":"__call__","text":"<pre><code>__call__(users: DataFrame, vouches: DataFrame) -&gt; DataFrame\n</code></pre> <p>Propagates trust through vouch network</p> <p>Parameters:</p> Name Type Description Default <code>users</code> <code>DataFrame</code> <p>with columns</p> <ul> <li>user_id (int, index)</li> <li>is_pretrusted (bool)</li> </ul> required <code>vouches</code> <code>DataFrame</code> <p>with columns</p> <ul> <li>voucher (str)</li> <li>vouchee (str)</li> <li>vouch (float)</li> </ul> required <p>Returns:</p> Name Type Description <code>users</code> <code>DataFrame</code> <p>with columns</p> <ul> <li>user_id (int, index)</li> <li>is_pretrusted (bool)</li> <li>trust_score (float)</li> </ul>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.TrustPropagation.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.NoTrustPropagation","title":"NoTrustPropagation","text":"<pre><code>NoTrustPropagation(pretrust_value: float = 0.8)\n</code></pre> <p>               Bases: <code>TrustPropagation</code></p> <p>Implements no trust propagation. The result trust_score is directly based on the \"pretrusted\" status of each user.</p> <p>Parameters:</p> Name Type Description Default <code>pretrust_value</code> <code>float</code> <p>trust score to assign to pretrusted users</p> <code>0.8</code>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.NoTrustPropagation.pretrust_value","title":"pretrust_value","text":"<pre><code>pretrust_value = pretrust_value\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.NoTrustPropagation.__call__","title":"__call__","text":"<pre><code>__call__(users: DataFrame, vouches: DataFrame) -&gt; DataFrame\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.NoTrustPropagation.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.LipschiTrust","title":"LipschiTrust","text":"<pre><code>LipschiTrust(\n    pretrust_value: float = 0.8,\n    decay: float = 0.8,\n    sink_vouch: float = 5.0,\n    error: float = 1e-08,\n)\n</code></pre> <p>               Bases: <code>TrustPropagation</code></p> <p>A robustified variant of PageRank. In this algorithm, we leverage pre-trust (e.g., based on email domains) and vouching to securely assign trust scores to a wider set of contributors. The algorithm inputs pre-trust status and a vouching directed graph.</p> <p>Parameters:</p> Name Type Description Default <code>pretrust_value</code> <code>float</code> <p>The pretrust of a pretrusted user. (\\(Trust^{pre}_{\\checkmark}\\) in paper) The algorithm guarantees that every pre-trusted user is given a trust score which is at least <code>pretrust_value</code>. Moreover, all users' trust score will be at most 1.</p> <code>0.8</code> <code>decay</code> <code>float</code> <p>The decay of trusts in voucher's vouchees. (\\(\\beta\\) in paper) When considering a random walker on the vouch network, (1 - <code>decay</code>) is the probability that the random walker resets its walk at each iteration. LipschiTrust essentially robustifies the random walk, by frequently preventing the walker from visiting too frequently visited contributors, thereby bounding the maximal influence of such contributors.</p> <code>0.8</code> <code>sink_vouch</code> <code>float</code> <p>used to incentivize vouching (\\(V^{sink}_{\\checkmark}\\) in paper) In our model we assume that each participating contributor implicitly vouches for a sink. The sink counts for <code>sink_vouch</code> vouchees. As a result, when a contributor with less than <code>sink_vouch</code> vouchees vouches for more vouchees, the amount of trust scores the contributor assigns grows almost linearly, thereby not penalizing previously vouched contributors. Vouching is thereby not (too) disincentivized.</p> <code>5.0</code> <code>error</code> <code>float</code> <p>Positive, is an upper bound on error, in L1 norm. \\(\\epsilon_{LipschiTrust}\\) in paper</p> <code>1e-08</code>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.LipschiTrust.pretrust_value","title":"pretrust_value","text":"<pre><code>pretrust_value = pretrust_value\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.LipschiTrust.decay","title":"decay","text":"<pre><code>decay = decay\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.LipschiTrust.sink_vouch","title":"sink_vouch","text":"<pre><code>sink_vouch = sink_vouch\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.LipschiTrust.error","title":"error","text":"<pre><code>error = error\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.LipschiTrust.__call__","title":"__call__","text":"<pre><code>__call__(users: DataFrame, vouches: DataFrame) -&gt; DataFrame\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.LipschiTrust.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.NoopTrust","title":"NoopTrust","text":"<p>               Bases: <code>TrustPropagation</code></p> <p>Noop implementation for trust propagation: trust values are simply read from the input <code>users</code>.</p>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.NoopTrust.__call__","title":"__call__","text":"<pre><code>__call__(\n    users: DataFrame, _vouches: DataFrame\n) -&gt; DataFrame\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.NoopTrust.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.TrustAll","title":"TrustAll","text":"<p>               Bases: <code>TrustPropagation</code></p> <p>A naive implementation that assigns an equal amount of trust to all users.</p>"},{"location":"modules/trust_propagation/#solidago.trust_propagation.TrustAll.__call__","title":"__call__","text":"<pre><code>__call__(users: DataFrame, vouches: DataFrame)\n</code></pre>"},{"location":"modules/voting_rights/","title":"Voting rights","text":"<p>Step 2 in the pipeline</p> <p>Voting rights are assigned per user and per entity, based on users' trust scores and privacy settings.</p>"},{"location":"modules/voting_rights/#solidago.voting_rights.VotingRightsAssignment","title":"VotingRightsAssignment","text":"<p>               Bases: <code>ABC</code></p>"},{"location":"modules/voting_rights/#solidago.voting_rights.VotingRightsAssignment.__call__","title":"__call__","text":"<pre><code>__call__(\n    users: DataFrame,\n    entities: DataFrame,\n    vouches: DataFrame,\n    privacy: PrivacySettings,\n) -&gt; tuple[VotingRights, DataFrame]\n</code></pre> <p>Compute voting rights</p> <p>Parameters:</p> Name Type Description Default <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, index)</li> </ul> required <code>vouches</code> <code>DataFrame</code> <ul> <li>voucher (int)</li> <li>vouchee (int)</li> <li>vouch (float)</li> </ul> required <code>privacy</code> <code>PrivacySettings</code> <p>privacy[user, entity] in { True, False, None }</p> required <p>Returns:</p> Name Type Description <code>voting_rights[user, entity] is the voting right</code> <p>of a user on entity for criterion</p> <code>entities</code> <code>DataFrame with columns</code> <ul> <li>entity_id (int, index)</li> </ul>"},{"location":"modules/voting_rights/#solidago.voting_rights.VotingRightsAssignment.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/voting_rights/#solidago.voting_rights.IsTrust","title":"IsTrust","text":"<pre><code>IsTrust(privacy_penalty: float = 0.5)\n</code></pre> <p>               Bases: <code>VotingRightsAssignment</code></p> <p>Implements voting rights assignment directly based on user trust scores and applying some privacy penalty.</p> <p>Parameters:</p> Name Type Description Default <code>privacy_penalty</code> <code>float</code> <p>Penalty on private comparisons.</p> <code>0.5</code>"},{"location":"modules/voting_rights/#solidago.voting_rights.IsTrust.privacy_penalty","title":"privacy_penalty","text":"<pre><code>privacy_penalty = privacy_penalty\n</code></pre>"},{"location":"modules/voting_rights/#solidago.voting_rights.IsTrust.__call__","title":"__call__","text":"<pre><code>__call__(\n    users: DataFrame,\n    entities: DataFrame,\n    vouches: DataFrame,\n    privacy: DataFrame,\n) -&gt; tuple[VotingRights, DataFrame]\n</code></pre> <p>Compute voting rights</p> <p>Parameters:</p> Name Type Description Default <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, index)</li> </ul> required <code>vouches</code> <code>DataFrame</code> <ul> <li>voucher (int)</li> <li>vouchee (int)</li> <li>vouch (float)</li> </ul> required <code>privacy</code> <code>DataFrame</code> <p>privacy[user, entity] in { True, False, None }</p> required <p>Returns:</p> Name Type Description <code>voting_rights[user, entity] is the voting right</code> <p>of a user on entity for criterion</p> <code>entities</code> <code>DataFrame with columns</code> <ul> <li>entity_id (int, index)</li> </ul>"},{"location":"modules/voting_rights/#solidago.voting_rights.IsTrust.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust","title":"AffineOvertrust","text":"<pre><code>AffineOvertrust(\n    privacy_penalty: float = 0.5,\n    min_overtrust: float = 2.0,\n    overtrust_ratio: float = 0.1,\n)\n</code></pre> <p>               Bases: <code>VotingRightsAssignment</code></p> <p>Initializes the AffineOvertrust model with the specified parameters.</p> <p>Parameters:</p> Name Type Description Default <code>privacy_penalty</code> <code>float</code> <p>Penalty on private comparisons.</p> <code>0.5</code> <code>min_overtrust</code> <code>float</code> <p>Minimum overtrust amount to distribute over all users.</p> <code>2.0</code> <code>overtrust_ratio</code> <code>float</code> <p>Trust ratio used to compute maximal allowed overtrust.</p> <code>0.1</code>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.privacy_penalty","title":"privacy_penalty","text":"<pre><code>privacy_penalty = privacy_penalty\n</code></pre>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.min_overtrust","title":"min_overtrust","text":"<pre><code>min_overtrust = min_overtrust\n</code></pre>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.overtrust_ratio","title":"overtrust_ratio","text":"<pre><code>overtrust_ratio = overtrust_ratio\n</code></pre>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.__call__","title":"__call__","text":"<pre><code>__call__(\n    users: DataFrame,\n    entities: DataFrame,\n    vouches: DataFrame,\n    privacy: PrivacySettings,\n) -&gt; tuple[VotingRights, DataFrame]\n</code></pre> <p>Compute voting rights for users on entities</p> <p>Parameters:</p> Name Type Description Default <code>users</code> <code>DataFrame</code> <ul> <li>user_id (int, index)</li> <li>trust_score (float)</li> </ul> required <code>entities</code> <code>DataFrame</code> <ul> <li>entity_id (int, index)</li> </ul> required <code>vouches</code> <code>DataFrame</code> <p>This is not used by VotingRightsWithLimitedOvertrust</p> required <code>privacy</code> <code>PrivacySettings</code> <p>privacy[user, entity] is the privacy setting of user for entity May be True, False or None</p> required <p>Returns:</p> Name Type Description <code>voting_rights[user, entity] is the voting right</code> <p>of a user on entity for criterion</p> <code>entities</code> <code>DataFrame with columns</code> <ul> <li>entity_id (int, index)</li> <li>cumulative_trust (float)</li> <li>min_voting_right (float)</li> <li>overtrust (float)</li> </ul>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.compute_entity_voting_rights","title":"compute_entity_voting_rights","text":"<pre><code>compute_entity_voting_rights(\n    trust_scores: Series, privacy_weights: Series\n) -&gt; tuple[Series, float, float, float]\n</code></pre>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.cumulative_trust","title":"cumulative_trust","text":"<pre><code>cumulative_trust(\n    trust_scores: ndarray, privacy_weights: ndarray\n) -&gt; float\n</code></pre> <p>Returns the sum of trusts of raters of entity entity_id, weighted by their privacy setting.</p> <p>Parameters:</p> Name Type Description Default <code>trust_scores</code> <code>ndarray</code> <ul> <li>index \"user_id (int, index)</li> <li>values \"trust_score\" (float)</li> </ul> required <code>privacy_weights</code> <code>ndarray</code> <p>privacy_weights[u] is the privacy weight of user u</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>float</code>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.maximal_overtrust","title":"maximal_overtrust","text":"<pre><code>maximal_overtrust(trust: float) -&gt; float\n</code></pre> <p>Computes the maximal allowed overtrust of an entity, for a given total trust of the entity's raters.</p> <p>Parameters:</p> Name Type Description Default <code>trust</code> <code>float</code> <p>Cumulative trust received by the entity</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>float</code>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.overtrust","title":"overtrust","text":"<pre><code>overtrust(\n    min_voting_right: float,\n    trust_scores: ndarray,\n    privacy_weights: ndarray,\n) -&gt; float\n</code></pre> <p>Returns the overtrust, if min_voting_right is enforced upon all raters.</p> <p>Parameters:</p> Name Type Description Default <code>min_voting_right</code> <code>float</code> <p>Overtrust for min_voting_right</p> required <code>trust_scores</code> <code>ndarray</code> <p>values: trust_score (float)</p> required <code>privacy_weights</code> <code>ndarray</code> <p>values: privacy weight of user</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>float</code>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.min_voting_right","title":"min_voting_right","text":"<pre><code>min_voting_right(\n    max_overtrust: float,\n    trust_scores: ndarray,\n    privacy_weights: ndarray,\n) -&gt; float\n</code></pre> <p>Returns the minimal voting rights that corresponds to max_overtrust.</p> <p>Parameters:</p> Name Type Description Default <code>max_overtrust</code> <code>float</code> <p>Maximal overtrust allowed for entity_id</p> required <code>trust_scores</code> <code>ndarray</code> <p>trust score values per user</p> required <code>privacy_weights</code> <code>ndarray</code> <p>privacy weight per user</p> required <p>Returns:</p> Name Type Description <code>out</code> <code>float</code>"},{"location":"modules/voting_rights/#solidago.voting_rights.AffineOvertrust.to_json","title":"to_json","text":"<pre><code>to_json()\n</code></pre>"},{"location":"structures/privacy_settings/","title":"Privacy settings","text":""},{"location":"structures/privacy_settings/#solidago.privacy_settings.PrivacySettings","title":"PrivacySettings","text":"<pre><code>PrivacySettings(dct=None)\n</code></pre>"},{"location":"structures/privacy_settings/#solidago.privacy_settings.PrivacySettings.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    user_entity_tuple: tuple[int, int]\n) -&gt; Optional[bool]\n</code></pre> <p>Returns the user's privacy setting for a given entity The result may be True (for private), False (for public) or None (if undefined).</p> <p>Parameters:</p> Name Type Description Default <code>user_entity_tuple</code> <code>tuple[int, int]</code> required <p>Returns:</p> Type Description <code>(True(private), False(public) or None(undefined))</code>"},{"location":"structures/privacy_settings/#solidago.privacy_settings.PrivacySettings.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    user_entity_tuple: tuple[int, int],\n    is_private: Optional[bool],\n)\n</code></pre> <p>Returns the user's privacy setting for a given entity The result may be True (for private), False (for public) or None (if undefined).</p> <p>Parameters:</p> Name Type Description Default <code>user_entity_tuple</code> <code>tuple[int, int]</code> required <code>is_private</code> <code>Optional[bool]</code> required"},{"location":"structures/privacy_settings/#solidago.privacy_settings.PrivacySettings.entities","title":"entities","text":"<pre><code>entities(user: Optional[int] = None) -&gt; set[int]\n</code></pre>"},{"location":"structures/privacy_settings/#solidago.privacy_settings.PrivacySettings.users","title":"users","text":"<pre><code>users(entity: Optional[int] = None) -&gt; set[int]\n</code></pre>"},{"location":"structures/scoring_model/","title":"Scoring model","text":""},{"location":"structures/scoring_model/#solidago.scoring_model.ScoringModel","title":"ScoringModel","text":"<p>Abstract class that defines the interface for models that can score individual entities.</p>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScoringModel.__call__","title":"__call__","text":"<pre><code>__call__(\n    entity_id: int, entity_features: Optional[Series] = None\n) -&gt; Optional[tuple[float, float, float]]\n</code></pre> <p>Score a single entity and return its evaluation results.</p> <p>Parameters:</p> Name Type Description Default <code>entity_id</code> <code>int</code> required <code>entity_features</code> <code>Optional[Series]</code> <p>Features of the entity that may be used for scoring.</p> <code>None</code> <p>Returns:</p> Type Description <code>Optional[tuple[float, float, float]]</code> <p>If scoring is successful, returns a tuple of three float values representing (score, left_uncertainty, right_uncertainty). Returns <code>None</code> if the entity cannot be scored</p>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScoringModel.scored_entities","title":"scored_entities","text":"<pre><code>scored_entities(\n    entities: Optional[DataFrame] = None,\n) -&gt; set[int]\n</code></pre> <p>Get the set of entity IDs that can be scored by this model.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>Optional[DataFrame]</code> <p>DataFrame containing entities to score with their features. If <code>None</code>, uses internally stored entities.</p> <code>None</code> <p>Returns:</p> Type Description <code>set[int]</code> <p>Set of entity IDs that are available for scoring.</p>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScoringModel.iter_entities","title":"iter_entities","text":"<pre><code>iter_entities(\n    entities=None,\n) -&gt; Iterable[tuple[int, tuple[float, float, float]]]\n</code></pre> <p>Iterate over all available entities and yield their scoring results.</p> <p>Parameters:</p> Name Type Description Default <code>entities</code> <code>DataFrame</code> <p>DataFrame containing entity features. If <code>None</code>, uses internally stored entities.</p> <code>None</code> <p>Yields:</p> Type Description <code>tuple[int, tuple[float, float, float]]</code> <p>Pairs of (entity_id, scoring_results) for each entity that can be scored.</p> Notes <p>This method provides a default implementation that calls <code>scored_entities()</code> to get available IDs and <code>__call__()</code> to score each entity.</p>"},{"location":"structures/scoring_model/#solidago.scoring_model.DirectScoringModel","title":"DirectScoringModel","text":"<pre><code>DirectScoringModel(\n    dct: Optional[\n        dict[int, tuple[float, float, float]]\n    ] = None\n)\n</code></pre> <p>               Bases: <code>ScoringModel</code></p> <p>A <code>ScoringModel</code> that contains scores directly assigned to each entity.</p>"},{"location":"structures/scoring_model/#solidago.scoring_model.DirectScoringModel.__call__","title":"__call__","text":"<pre><code>__call__(\n    entity_id: int, entity_features=None\n) -&gt; Optional[tuple[float, float, float]]\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.DirectScoringModel.__getitem__","title":"__getitem__","text":"<pre><code>__getitem__(\n    entity_id: int,\n) -&gt; Optional[tuple[float, float, float]]\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.DirectScoringModel.__setitem__","title":"__setitem__","text":"<pre><code>__setitem__(\n    entity_id: int,\n    score_and_uncertainties: Union[\n        tuple[float, float, float], tuple[float, float]\n    ],\n)\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.DirectScoringModel.scored_entities","title":"scored_entities","text":"<pre><code>scored_entities(entities=None) -&gt; set[int]\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.DirectScoringModel.iter_entities","title":"iter_entities","text":"<pre><code>iter_entities(\n    entities=None,\n) -&gt; Iterable[tuple[int, tuple[float, float, float]]]\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel","title":"ScaledScoringModel","text":"<pre><code>ScaledScoringModel(\n    base_model: ScoringModel,\n    multiplicator: float = 1.0,\n    translation: float = 0.0,\n    multiplicator_left_uncertainty: float = 0.0,\n    multiplicator_right_uncertainty: float = 0.0,\n    translation_left_uncertainty: float = 0.0,\n    translation_right_uncertainty: float = 0.0,\n)\n</code></pre> <p>               Bases: <code>ScoringModel</code></p> <p>A <code>ScoringModel</code> with scaling parameters applied.</p> <p>When <code>base_model</code> is itself a scaled scoring model, the scalings are aggregated, so that the base model is actually the scaled scoring model's base model.</p> <p>Note</p> <p>Note that this requires aggregating the uncertainties in a heuristic manner. At the core, this is because the uncertainties should grow quadratically with the size of the scores. Put differently, because of uncertainties, the composition of scaled scoring models is not an internal composition law (but it is if uncertainties are not accounted for).</p>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.base_model","title":"base_model","text":"<pre><code>base_model = base_model\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.multiplicator","title":"multiplicator","text":"<pre><code>multiplicator = multiplicator * multiplicator\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.translation","title":"translation","text":"<pre><code>translation = translation + multiplicator * translation\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.multiplicator_left_uncertainty","title":"multiplicator_left_uncertainty","text":"<pre><code>multiplicator_left_uncertainty = (\n    multiplicator_left_uncertainty\n    + multiplicator * multiplicator_left_uncertainty\n)\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.multiplicator_right_uncertainty","title":"multiplicator_right_uncertainty","text":"<pre><code>multiplicator_right_uncertainty = (\n    multiplicator_right_uncertainty\n    + multiplicator * multiplicator_right_uncertainty\n)\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.translation_left_uncertainty","title":"translation_left_uncertainty","text":"<pre><code>translation_left_uncertainty = (\n    translation_left_uncertainty\n    + multiplicator * translation_left_uncertainty\n)\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.translation_right_uncertainty","title":"translation_right_uncertainty","text":"<pre><code>translation_right_uncertainty = (\n    translation_right_uncertainty\n    + multiplicator * translation_right_uncertainty\n)\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.__call__","title":"__call__","text":"<pre><code>__call__(entity_id, entity_features=None)\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.scale_score","title":"scale_score","text":"<pre><code>scale_score(\n    base_score, base_left_unc, base_right_unc\n) -&gt; tuple[float, float, float]\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.scored_entities","title":"scored_entities","text":"<pre><code>scored_entities(entities=None) -&gt; set[int]\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.iter_entities","title":"iter_entities","text":"<pre><code>iter_entities(\n    entities=None,\n) -&gt; Iterable[tuple[int, tuple[float, float, float]]]\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.ScaledScoringModel.compose_scaling_parameters","title":"compose_scaling_parameters","text":"<pre><code>compose_scaling_parameters(parameters)\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.PostProcessedScoringModel","title":"PostProcessedScoringModel","text":"<pre><code>PostProcessedScoringModel(\n    base_model: ScoringModel, post_process: Callable\n)\n</code></pre> <p>               Bases: <code>ScoringModel</code></p> <p>Defines a derived scoring model, based on a base model and a post process</p> <p>Parameters:</p> Name Type Description Default <code>base_model</code> <code>ScoringModel</code> required <code>post_process</code> <code>Callable</code> <p>Must be a monotonous function float -&gt; float</p> required"},{"location":"structures/scoring_model/#solidago.scoring_model.PostProcessedScoringModel.base_model","title":"base_model","text":"<pre><code>base_model = base_model\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.PostProcessedScoringModel.post_process","title":"post_process","text":"<pre><code>post_process = post_process\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.PostProcessedScoringModel.__call__","title":"__call__","text":"<pre><code>__call__(entity_id, entity_features=None)\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.PostProcessedScoringModel.apply_post_process","title":"apply_post_process","text":"<pre><code>apply_post_process(\n    base_score, base_left_unc, base_right_unc\n)\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.PostProcessedScoringModel.scored_entities","title":"scored_entities","text":"<pre><code>scored_entities(entities=None) -&gt; set[int]\n</code></pre>"},{"location":"structures/scoring_model/#solidago.scoring_model.PostProcessedScoringModel.iter_entities","title":"iter_entities","text":"<pre><code>iter_entities(\n    entities=None,\n) -&gt; Iterable[tuple[int, tuple[float, float, float]]]\n</code></pre>"}]}