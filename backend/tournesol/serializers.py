"""
Serializer used by Tournesol's API
"""

from typing import Optional

from django.db import IntegrityError, transaction
from django.db.models import ObjectDoesNotExist, Q
from drf_spectacular.types import OpenApiTypes
from drf_spectacular.utils import extend_schema_field
from rest_framework import serializers
from rest_framework.exceptions import NotFound, ValidationError
from rest_framework.fields import BooleanField, RegexField, SerializerMethodField
from rest_framework.serializers import ModelSerializer, Serializer

from core.utils.constants import YOUTUBE_VIDEO_ID_REGEX
from tournesol.errors import ConflictError
from tournesol.utils.api_youtube import VideoNotFound

from .models import (
    Comparison,
    ComparisonCriteriaScore,
    ContributorRating,
    ContributorRatingCriteriaScore,
    Video,
    VideoCriteriaScore,
    VideoRateLater,
)


class VideoSerializer(ModelSerializer):
    duration = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "video_id",
            "name",
            "description",
            "publication_date",
            "views",
            "uploader",
            "language",
            "rating_n_ratings",
            "rating_n_contributors",
            "duration",
        ]
        read_only_fields = [
            "name",
            "description",
            "publication_date",
            "views",
            "uploader",
            "language",
            "rating_n_ratings",
            "rating_n_contributors",
            "duration",
        ]

    def create(self, validated_data):
        try:
            return Video.create_from_video_id(validated_data["video_id"])
        except VideoNotFound:
            raise NotFound("The video has not been found. `video_id` may be incorrect.")

    # Convert duration to seconds to facilitate use of Humanize package
    def get_duration(self, obj) -> Optional[int]:
        if obj.duration:
            return int(obj.duration.total_seconds())
        return None


class RelatedVideoSerializer(VideoSerializer):
    """
    A video serializer that will create the Video object on validation
    if it does not exist in the database yet.

    Used by ModelSerializer(s) having one or more nested relations with Video,
    and having the constraint to ensure that video instances exist before
    they can be saved properly.
    """

    video_id = RegexField(YOUTUBE_VIDEO_ID_REGEX)

    def validate_video_id(self, value):
        try:
            Video.objects.get(video_id=value)
        except ObjectDoesNotExist:
            try:
                Video.create_from_video_id(value)
            except VideoNotFound:
                raise ValidationError("The video has not been found. `video_id` may be incorrect.")
        return value


class VideoCriteriaScoreSerializer(ModelSerializer):
    class Meta:
        model = VideoCriteriaScore
        fields = ["criteria", "score", "uncertainty", "quantile"]


class VideoSerializerWithCriteria(VideoSerializer):
    criteria_scores = VideoCriteriaScoreSerializer(many=True)

    class Meta(VideoSerializer.Meta):
        fields = VideoSerializer.Meta.fields + ['criteria_scores']
        # Overriding 'read_only_fields' should not be necessary here. However, due to a
        # limitation in DRF, some extra attributes from model fields (nullable, etc.) are
        # not present in the schema generated by drf-spectacular for read_only fields.
        # See https://github.com/tfranzel/drf-spectacular/issues/383 for more details.
        # This serializer is always used as read-only, so the 'read_only_fields' definition
        # can be discarded safely to generate a correct OpenAPI schema.
        read_only_fields = []


class VideoRateLaterSerializer(ModelSerializer):
    video = RelatedVideoSerializer()
    user = serializers.HiddenField(default=serializers.CurrentUserDefault())

    class Meta:
        model = VideoRateLater
        fields = ["user", "video"]

    def create(self, validated_data):
        video_id = validated_data.pop("video")["video_id"]
        video = Video.objects.get(video_id=video_id)
        try:
            return super().create({"video": video, **validated_data})
        except IntegrityError:
            raise ConflictError


class ComparisonCriteriaScoreSerializer(ModelSerializer):
    class Meta:
        model = ComparisonCriteriaScore
        fields = ["criteria", "score", "weight"]


class ComparisonSerializerMixin:
    def reverse_criteria_scores(self, criteria_scores):
        opposite_scores = criteria_scores.copy()
        for index, score in enumerate(criteria_scores):
            opposite_scores[index]["score"] = score["score"] * -1

        return opposite_scores


class ComparisonSerializer(ComparisonSerializerMixin, ModelSerializer):
    """
    A comparison serializer used for the operations create, retrieve and list.

    Given the context determined by the view, it will represent the comparison
    in the reverse order.

    Use `ComparisonUpdateSerializer` for the update operation.
    """

    video_a = RelatedVideoSerializer(source="video_1")
    video_b = RelatedVideoSerializer(source="video_2")
    criteria_scores = ComparisonCriteriaScoreSerializer(many=True)
    user = serializers.HiddenField(default=serializers.CurrentUserDefault())

    class Meta:
        model = Comparison
        fields = ["user", "video_a", "video_b", "criteria_scores", "duration_ms"]

    def to_representation(self, instance):
        """
        Display the opposite of each criteria scores if the comparison is
        requested in the reverse order.
        """
        ret = super(ComparisonSerializer, self).to_representation(instance)

        if self.context.get("reverse", False):
            ret["video_a"], ret["video_b"] = ret["video_b"], ret["video_a"]
            ret["criteria_scores"] = self.reverse_criteria_scores(
                ret["criteria_scores"]
            )

        return ret

    @transaction.atomic
    def create(self, validated_data):
        video_id_1 = validated_data.pop("video_1").get("video_id")
        video_id_2 = validated_data.pop("video_2").get("video_id")
        # the validation performed by the RelatedVideoSerializer guarantees
        # that the videos submitted exist in the database
        video_1 = Video.objects.get(video_id=video_id_1)
        video_2 = Video.objects.get(video_id=video_id_2)
        criteria_scores = validated_data.pop("criteria_scores")

        comparison = Comparison.objects.create(
            video_1=video_1,
            video_2=video_2,
            **validated_data,
        )

        for criteria_score in criteria_scores:
            ComparisonCriteriaScore.objects.create(
                comparison=comparison, **criteria_score
            )

        return comparison


class ComparisonUpdateSerializer(ComparisonSerializerMixin, ModelSerializer):
    """
    A comparison serializer used only for updates.

    Given the context determined by the view, it will represent or save the
    comparison in the reverse order.

    Use `ComparisonSerializer` for all other operations.
    """

    criteria_scores = ComparisonCriteriaScoreSerializer(many=True)
    video_a = VideoSerializer(source="video_1", read_only=True)
    video_b = VideoSerializer(source="video_2", read_only=True)

    class Meta:
        model = Comparison
        fields = ["criteria_scores", "duration_ms", "video_a", "video_b"]

    def to_representation(self, instance):
        """
        Display the opposite of each criteria scores if the comparison is
        requested in the reverse order.

        Also add `video_a` and `video_b` fields to make the representation
        consistent across all comparison serializers.
        """
        ret = super(ComparisonUpdateSerializer, self).to_representation(instance)

        if self.context.get("reverse", False):
            ret["video_a"], ret["video_b"] = ret["video_b"], ret["video_a"]
            ret["criteria_scores"] = self.reverse_criteria_scores(
                ret["criteria_scores"]
            )

        ret.move_to_end("video_b", last=False)
        ret.move_to_end("video_a", last=False)
        return ret

    def to_internal_value(self, data):
        """
        Save the comparison in the order expected by the model, even if the
        comparison is provided reversed.
        """
        ret = super(ComparisonUpdateSerializer, self).to_internal_value(data)

        if self.context.get("reverse", False):
            ret["criteria_scores"] = self.reverse_criteria_scores(
                ret["criteria_scores"]
            )
        return ret

    @transaction.atomic
    def update(self, instance, validated_data):
        if validated_data.get("duration_ms"):
            instance.duration_ms = validated_data.get("duration_ms")

        instance.save()
        instance.criteria_scores.all().delete()

        for criteria_score in validated_data.pop("criteria_scores"):
            instance.criteria_scores.create(**criteria_score)

        return instance


class ContributorCriteriaScore(ModelSerializer):
    class Meta:
        model = ContributorRatingCriteriaScore
        fields = ["criteria", "score", "uncertainty"]


class ContributorRatingSerializer(ModelSerializer):
    video = VideoSerializer(read_only=True)
    criteria_scores = ContributorCriteriaScore(many=True, read_only=True)
    n_comparisons = SerializerMethodField(
        help_text="Number of comparisons submitted by the current user about the current video",
    )

    class Meta:
        model = ContributorRating
        fields = ["video", "is_public", "criteria_scores", "n_comparisons"]

    @extend_schema_field(OpenApiTypes.INT)
    def get_n_comparisons(self, obj):
        if hasattr(obj, "n_comparisons"):
            # Use annotated field if it has been defined by the queryset
            return obj.n_comparisons
        return obj.user.comparisons.filter(
            Q(video_1=obj.video) | Q(video_2=obj.video)
        ).count()


class ContributorRatingCreateSerializer(ContributorRatingSerializer):
    video_id = RegexField(YOUTUBE_VIDEO_ID_REGEX, write_only=True)

    class Meta:
        model = ContributorRating
        fields = ["video_id", "is_public", "video", "criteria_scores", "n_comparisons"]

    def validate(self, attrs):
        video_id = attrs.pop("video_id")
        video_serializer = RelatedVideoSerializer(data={"video_id": video_id})
        video_serializer.is_valid(raise_exception=True)
        video = Video.objects.get(video_id=video_id)
        user = self.context["request"].user
        if user.contributorvideoratings.filter(video=video).exists():
            raise ValidationError(
                "A ContributorRating already exists for this (user, video)",
                code='unique',
            )
        attrs["video"] = video
        attrs["user"] = user
        return attrs


class ContributorRatingUpdateAllSerializer(Serializer):
    is_public = BooleanField()
