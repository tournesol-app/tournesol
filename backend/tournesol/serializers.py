"""
Serializer used by Tournesol's API
"""

from typing import Optional

from django.db import transaction
from django.db.models import ObjectDoesNotExist, Q
from drf_spectacular.types import OpenApiTypes
from drf_spectacular.utils import extend_schema_field
from rest_framework import serializers
from rest_framework.exceptions import ValidationError
from rest_framework.fields import BooleanField, IntegerField, RegexField, SerializerMethodField
from rest_framework.serializers import ModelSerializer, Serializer

from core.utils.constants import YOUTUBE_VIDEO_ID_REGEX

from .models import (
    Comparison,
    ComparisonCriteriaScore,
    ContributorRating,
    ContributorRatingCriteriaScore,
    Tag,
    Video,
    VideoCriteriaScore,
    VideoRateLater,
)


class VideoSerializer(ModelSerializer):
    duration = serializers.SerializerMethodField()

    class Meta:
        model = Video
        fields = [
            "video_id",
            "name",
            "description",
            "publication_date",
            "views",
            "uploader",
            "language",
            "rating_n_ratings",
            "rating_n_contributors",
            "duration",
        ]
        read_only_fields = [
            "name",
            "description",
            "publication_date",
            "views",
            "uploader",
            "language",
            "rating_n_ratings",
            "rating_n_contributors",
            "duration",
        ]

    def save(self, **kwargs):
        tags = kwargs.pop('tags', [])
        video = super().save(**kwargs)
        for tag_name in tags:
            #  The return object is a tuple having first an instance of Tag, and secondly a bool
            tag = Tag.objects.get_or_create(name=tag_name)
            video.tags.add(tag[0].id)
        return video

    # Convert duration to seconds to facilitate use of Humanize package
    def get_duration(self, obj) -> Optional[int]:
        if obj.duration:
            return int(obj.duration.total_seconds())
        return None


class VideoReadOnlySerializer(Serializer):
    """
    A video serializer without all the Video model auto-validations.

    Used by ModelSerializer(s) having one or more nested relations with Video,
    and having the constraint of not creating new videos in database when
    creating new objects.

    ex: adding a new Comparison shouldn't create new Video in the database
    """

    video_id = serializers.CharField(max_length=20)

    class Meta:
        fields = ["video_id"]

    def validate_video_id(self, value):
        try:
            Video.objects.get(video_id=value)
        except ObjectDoesNotExist:
            raise serializers.ValidationError(
                "The video with id '{}' does not exist.".format(value)
            )
        return value


class VideoCriteriaScoreSerializer(ModelSerializer):
    class Meta:
        model = VideoCriteriaScore
        fields = ["criteria", "score", "uncertainty", "quantile"]


class VideoSerializerWithCriteria(VideoSerializer):
    criteria_scores = VideoCriteriaScoreSerializer(many=True)

    class Meta(VideoSerializer.Meta):
        fields = VideoSerializer.Meta.fields + ['criteria_scores']
        # Overriding 'read_only_fields' should not be necessary here. However, due to a
        # limitation in DRF, some extra attributes from model fields (nullable, etc.) are
        # not present in the schema generated by drf-spectacular for read_only fields.
        # See https://github.com/tfranzel/drf-spectacular/issues/383 for more details.
        # This serializer is always used as read-only, so the 'read_only_fields' definition
        # can be discarded safely to generate a correct OpenAPI schema.
        read_only_fields = []


class VideoRateLaterSerializer(ModelSerializer):
    video = VideoSerializer()

    class Meta:
        model = VideoRateLater
        fields = ["video"]


class ComparisonCriteriaScoreSerializer(ModelSerializer):
    class Meta:
        model = ComparisonCriteriaScore
        fields = ["criteria", "score", "weight"]


class ComparisonSerializerMixin:
    def reverse_criteria_scores(self, criteria_scores):
        opposite_scores = criteria_scores.copy()
        for index, score in enumerate(criteria_scores):
            opposite_scores[index]["score"] = score["score"] * -1

        return opposite_scores


class ComparisonSerializer(ComparisonSerializerMixin, ModelSerializer):
    """
    A comparison serializer used for the operations create, retrieve and list.

    Given the context determined by the view, it will represent the comparison
    in the reverse order.

    Use `ComparisonUpdateSerializer` for the update operation.
    """

    video_a = VideoReadOnlySerializer(source="video_1")
    video_b = VideoReadOnlySerializer(source="video_2")
    criteria_scores = ComparisonCriteriaScoreSerializer(many=True)
    user = serializers.HiddenField(default=serializers.CurrentUserDefault())

    class Meta:
        model = Comparison
        fields = ["user", "video_a", "video_b", "criteria_scores", "duration_ms"]

    def to_representation(self, instance):
        """
        Display the opposite of each criteria scores if the comparison is
        requested in the reverse order.
        """
        ret = super(ComparisonSerializer, self).to_representation(instance)

        if self.context.get("reverse", False):
            ret["video_a"], ret["video_b"] = ret["video_b"], ret["video_a"]
            ret["criteria_scores"] = self.reverse_criteria_scores(
                ret["criteria_scores"]
            )

        return ret

    @transaction.atomic
    def create(self, validated_data):
        video_id_1 = validated_data.get("video_1").get("video_id")
        video_id_2 = validated_data.get("video_2").get("video_id")
        # the validation performed by the VideoReadOnlySerializer guarantees
        # that the video submitted exist in the database
        video_1 = Video.objects.get(video_id=video_id_1)
        video_2 = Video.objects.get(video_id=video_id_2)

        # get default values directly from the model
        default_duration_ms = Comparison._meta.get_field("duration_ms").get_default()

        comparison = Comparison.objects.create(
            video_1=video_1,
            video_2=video_2,
            user=validated_data.get("user"),
            duration_ms=validated_data.get("duration_ms", default_duration_ms),
        )

        for criteria_score in validated_data.pop("criteria_scores"):
            ComparisonCriteriaScore.objects.create(
                comparison=comparison, **criteria_score
            )

        return comparison


class ComparisonUpdateSerializer(ComparisonSerializerMixin, ModelSerializer):
    """
    A comparison serializer used only for updates.

    Given the context determined by the view, it will represent or save the
    comparison in the reverse order.

    Use `ComparisonSerializer` for all other operations.
    """

    criteria_scores = ComparisonCriteriaScoreSerializer(many=True)

    class Meta:
        model = Comparison
        fields = ["criteria_scores", "duration_ms"]

    def to_representation(self, instance):
        """
        Display the opposite of each criteria scores if the comparison is
        requested in the reverse order.

        Also add `video_a` and `video_b` fields to make the representation
        consistent across all comparison serializers.
        """
        ret = super(ComparisonUpdateSerializer, self).to_representation(instance)

        video_1_repr = VideoReadOnlySerializer().to_representation(instance.video_1)
        video_2_repr = VideoReadOnlySerializer().to_representation(instance.video_2)
        ret["video_a"], ret["video_b"] = video_1_repr, video_2_repr

        if self.context.get("reverse", False):
            ret["video_a"], ret["video_b"] = ret["video_b"], ret["video_a"]
            ret["criteria_scores"] = self.reverse_criteria_scores(
                ret["criteria_scores"]
            )

        ret.move_to_end("video_b", last=False)
        ret.move_to_end("video_a", last=False)
        return ret

    def to_internal_value(self, data):
        """
        Save the comparison in the order expected by the model, even if the
        comparison is provided reversed.
        """
        ret = super(ComparisonUpdateSerializer, self).to_internal_value(data)

        if self.context.get("reverse", False):
            ret["criteria_scores"] = self.reverse_criteria_scores(
                ret["criteria_scores"]
            )
        return ret

    @transaction.atomic
    def update(self, instance, validated_data):
        if validated_data.get("duration_ms"):
            instance.duration_ms = validated_data.get("duration_ms")

        instance.save()
        instance.criteria_scores.all().delete()

        for criteria_score in validated_data.pop("criteria_scores"):
            instance.criteria_scores.create(**criteria_score)

        return instance


class ContributorCriteriaScore(ModelSerializer):
    class Meta:
        model = ContributorRatingCriteriaScore
        fields = ["criteria", "score", "uncertainty"]


class ContributorRatingSerializer(ModelSerializer):
    video = VideoSerializer(read_only=True)
    criteria_scores = ContributorCriteriaScore(many=True, read_only=True)
    n_comparisons = SerializerMethodField(
        help_text="Number of comparisons submitted by the current user about the current video",
    )

    class Meta:
        model = ContributorRating
        fields = ["video", "is_public", "criteria_scores", "n_comparisons"]

    @extend_schema_field(OpenApiTypes.INT)
    def get_n_comparisons(self, obj):
        if hasattr(obj, "n_comparisons"):
            # Use annotated field if it has been defined by the queryset
            return obj.n_comparisons
        return obj.user.comparisons.filter(
            Q(video_1=obj.video) | Q(video_2=obj.video)
        ).count()


class ContributorRatingCreateSerializer(ContributorRatingSerializer):
    video_id = RegexField(YOUTUBE_VIDEO_ID_REGEX, write_only=True)

    class Meta:
        model = ContributorRating
        fields = ["video_id", "is_public", "video", "criteria_scores", "n_comparisons"]

    def validate(self, attrs):
        video_id = attrs.pop("video_id")
        try:
            video = Video.objects.get(video_id=video_id)
        except Video.DoesNotExist:
            raise ValidationError(f"Video with video_id '{video_id}' does not exist")

        user = self.context["request"].user
        if user.contributorvideoratings.filter(video=video).exists():
            raise ValidationError(
                "A ContributorRating already exists for this (user, video)",
                code='unique',
            )

        attrs["video"] = video
        attrs["user"] = user
        return attrs


class ContributorRatingUpdateAllSerializer(Serializer):
    is_public = BooleanField()


class StatisticsSerializer(Serializer):
    user_count = IntegerField()
    last_month_user_count = IntegerField()
    video_count = IntegerField()
    last_month_video_count = IntegerField()
    comparison_count = IntegerField()
    last_month_comparison_count = IntegerField()
